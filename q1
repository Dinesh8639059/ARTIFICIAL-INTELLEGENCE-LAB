import heapq

# Define the goal state
goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

# Define possible moves (up, down, left, right)
moves = [(0, -1), (0, 1), (-1, 0), (1, 0)]

class PuzzleNode:
    def __init__(self, state, parent=None, move=""):
        self.state = state
        self.parent = parent
        self.move = move
        self.cost = 0 if parent is None else parent.cost + 1
        self.heuristic = self.calculate_heuristic()
        self.priority = self.cost + self.heuristic

    def __lt__(self, other):
        return self.priority < other.priority

    def calculate_heuristic(self):
        # Calculate the Manhattan distance heuristic
        distance = 0
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 0:
                    continue
                x, y = divmod(self.state[i][j] - 1, 3)
                distance += abs(x - i) + abs(y - j)
        return distance

    def is_goal(self):
        return self.state == goal_state

    def generate_successors(self):
        successors = []
        x, y = self.find_blank()

        for dx, dy in moves:
            new_x, new_y = x + dx, y + dy
            if 0 <= new_x < 3 and 0 <= new_y < 3:
                new_state = [row[:] for row in self.state]
                new_state[x][y], new_state[new_x][new_y] = new_state[new_x][new_y], new_state[x][y]
                successors.append(PuzzleNode(new_state, self, move=f"Move {self.state[new_x][new_y]} {dx, dy}"))

        return successors

    def find_blank(self):
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 0:
                    return i, j

    def get_solution_path(self):
        path = []
        current = self
        while current:
            if current.move:
                path.append(current.move)
            current = current.parent
        path.reverse()
        return path

def solve_8_puzzle(initial_state):
    initial_node = PuzzleNode(initial_state)
    open_list = [initial_node]
    closed_list = set()

    while open_list:
        current_node = heapq.heappop(open_list)
        closed_list.add(tuple(map(tuple, current_node.state)))

        if current_node.is_goal():
            return current_node.get_solution_path()

        successors = current_node.generate_successors()

        for successor in successors:
            if tuple(map(tuple, successor.state)) not in closed_list:
                heapq.heappush(open_list, successor)

    return None

# Input the initial state as a list of lists (3x3 puzzle), where 0 represents the blank tile.
initial_state = []
for i in range(3):
    row = list(map(int, input(f"Enter row {i + 1} (e.g., 1 2 3, 0 for blank tile): ").split()))
    initial_state.append(row)

solution = solve_8_puzzle(initial_state)

if solution:
    print("Solution steps:")
    for i, step in enumerate(solution, start=1):
        print(f"Step {i}: {step}")
else:
    print("No solution found.")
